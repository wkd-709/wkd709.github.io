<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wkd709个人网站</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wkd709.github.io/"/>
  <updated>2018-08-24T02:20:47.578Z</updated>
  <id>https://wkd709.github.io/</id>
  
  <author>
    <name>wkd709</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>flex布局</title>
    <link href="https://wkd709.github.io/2018/08/24/flex%E5%B8%83%E5%B1%80/"/>
    <id>https://wkd709.github.io/2018/08/24/flex布局/</id>
    <published>2018-08-23T16:00:00.000Z</published>
    <updated>2018-08-24T02:20:47.578Z</updated>
    
    <content type="html"><![CDATA[<hr><p>[TOC]<br><br></p><blockquote><p>网页布局（layout）是css的一个重点应用。<br><br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt="enter description here"></p></blockquote><blockquote><p>布局的传统解决方案，基于盒状模型，依赖==display==属性 + ==float==属性。它对于那些特殊布局非常不便，比如，==垂直居中==就不容易实现。</p></blockquote><p>各大浏览器的兼容性如下:</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071003.jpg" alt="enter description here"><br>  <br><br>  <br></p><h2 id="一、Flex布局是什么？"><a href="#一、Flex布局是什么？" class="headerlink" title="一、Flex布局是什么？"></a>一、Flex布局是什么？</h2><hr><p>Flex是Flexible Box 的缩写，意为’弹性布局’，用来为盒状模型提供最大的灵活性。<br>任何一个容器都可以指定为Flex布局。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    display: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>行内元素也可以使用Flex布局。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    display: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webkit内核的浏览器，必须加上   ==-webkit-== 前缀。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    display: -webkit-flex; /* Safari */</span><br><span class="line">display: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：，设为Flex布局以后，子元素的 ==float==、==clear==和==vertical-aligin==属性将失效。</p><h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><hr><p>采用Flex布局的元素，称为Flex容器（flex container),简称“容器”。它的所有子元素自动称为容器成员，称为Flex项目（flex item),简称“项目”。<br><br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt="enter description here"></p><p>  容器默认存在两根轴：水平的主轴（main axis)。主轴的开始位置（与边框的交叉点）叫做==main start==，结束位置叫做 ==main end==;交叉轴的开始位置叫做==cross start==，结束位置叫做==cross end==。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做==main size==,占据的交叉轴空间叫做==cross size==。</p><h2 id="三、容器的属性"><a href="#三、容器的属性" class="headerlink" title="三、容器的属性"></a>三、容器的属性</h2><hr><p>以下6个属性设置在容器上。</p><blockquote><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul></blockquote><h3 id="3-1-flex-direction"><a href="#3-1-flex-direction" class="headerlink" title="3.1 flex-direction"></a>3.1 flex-direction</h3><hr><p>flex-direction 属性决定主轴的方向（即项目的排列方向）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    flex-direction: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四种：<br><br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png" alt="enter description here"></p><p>它可能有4个值。</p><blockquote><ul><li>row (默认值)： 主轴为水平方向，起点在左端。</li><li>row-reverse： 主轴为水平方向，起点在右端。</li><li>column： 主轴为垂直方向，起点在上沿。</li><li>column-reverse： 主轴为垂直方向，起点在下沿。</li></ul></blockquote><h3 id="3-2-flex-wrap属性"><a href="#3-2-flex-wrap属性" class="headerlink" title="3.2 flex-wrap属性"></a>3.2 flex-wrap属性</h3><hr><p>默认情况下，项目都排在一条线（又称‘轴线’）上。==flex-wrap==属性定义，如果一条轴线排不下，如何换行。<br><br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png" alt="enter description here"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    flex-wrap: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可能取三个值。<br>（1）、==nowrap==（默认）： 不换行<br><br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png" alt="enter description here"></p><p>（2）、==wrap==：换行，第一行在上方。<br><br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg" alt="enter description here"></p><p>（3）、==wrap-reverse==：换行，第一行在下方。<br><br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg" alt="enter description here"></p><h3 id="3-3-flex-flow"><a href="#3-3-flex-flow" class="headerlink" title="3.3 flex-flow"></a>3.3 flex-flow</h3><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-justify-content属性"><a href="#3-4-justify-content属性" class="headerlink" title="3.4 justify-content属性"></a>3.4 justify-content属性</h3><hr><p>==justify-content==属性定义了项目在主轴上的对齐方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    justify-content: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以下：<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png" alt="enter description here"></p><p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p><blockquote><ul><li>flex-start (默认值) : 左对齐</li><li>flex-end : 右对齐</li><li>center ： 居中</li><li>space-between : 两端对齐，项目之前的间隔都相等。</li><li>space-around : 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul></blockquote><h3 id="3-5-align-items属性"><a href="#3-5-align-items属性" class="headerlink" title="3.5 align-items属性"></a>3.5 align-items属性</h3><hr><p>==alig-items==属性定义项目在交叉轴上如何对齐。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">   align-items: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以下：<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png" alt="enter description here"></p><p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p><blockquote><ul><li>flex-start：交叉轴的起点对齐。</li><li>flex-end：交叉轴的终点对齐。</li><li>center：交叉轴的中点对齐。</li><li>baseline：项目的第一行文字的基线对齐。</li><li>stretch （默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul></blockquote><h3 id="3-6-align-content-属性"><a href="#3-6-align-content-属性" class="headerlink" title="3.6 align-content 属性"></a>3.6 align-content 属性</h3><hr><p>==align-content==属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">   align-content : flex-start | flex-end | center | space-between | space-around</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以下：<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" alt="enter description here"></p><p>该属性可能取6个值。</p><blockquote><ul><li>flex-start：与交叉轴的起点对齐。</li><li>flex-end：与交叉轴的终点对齐。</li><li>center：与交叉轴的中点对齐。</li><li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li>stretch （默认值）：轴线占满整个交叉轴。</li></ul></blockquote><h2 id="四、项目的属性"><a href="#四、项目的属性" class="headerlink" title="四、项目的属性"></a>四、项目的属性</h2><hr><p>以下6个属性设置在项目上。</p><blockquote><ul><li>order</li><li>flex-grow</li><li>flex-shrink </li><li>flex-basis</li><li>flex</li><li>align-self</li></ul></blockquote><h3 id="4-1-order属性"><a href="#4-1-order属性" class="headerlink" title="4.1 order属性"></a>4.1 order属性</h3><hr><p>==order==属性定义项目的排列顺序。数值越小，排列越靠前，默认为0；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">   order: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下:<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png" alt="enter description here"></p><h3 id="4-2-flex-grow属性"><a href="#4-2-flex-grow属性" class="headerlink" title="4.2 flex-grow属性"></a>4.2 flex-grow属性</h3><hr><p>==flex-grow==属性定义项目的放大比例，默认为==0==，即如果存在剩余空间，也不放大。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">   flex-grow: &lt;number&gt;; /* default 0*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下：<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png" alt="enter description here"></p><p>如果所有项目的==flex-grow==属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的==flex-grow==属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h3 id="4-3-flex-shrink属性"><a href="#4-3-flex-shrink属性" class="headerlink" title="4.3 flex-shrink属性"></a>4.3 flex-shrink属性</h3><hr><p>==flex-shrink==属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">   flex-shrink: &lt;number&gt;; /* default 1*/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下：<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg" alt="enter description here"></p><p>如果所有项目的==flex-shrink==属性都为1，当空间不足时，都将等比缩小。如果一个项目的==flex-shrink==属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><p>负值对该属性无效。</p><h3 id="4-4-flex-basis属性"><a href="#4-4-flex-basis属性" class="headerlink" title="4.4 flex-basis属性"></a>4.4 flex-basis属性</h3><hr><p>==flex-basis==属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否多余空间。它的默认值为==auto==,即项目的本来大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">    flex-basis: &lt;length&gt; | auto; /* default auto */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可以设为跟==width==或==height==属性一样的值（比如350px）,则项目占据固定空间。</p><h3 id="4-5-flex属性"><a href="#4-5-flex属性" class="headerlink" title="4.5 flex属性"></a>4.5 flex属性</h3><hr><p>==flex==属性是==flex-grow==,==flex-shrink==和==flex-basis==的简写，默认值为==0 1 auto==。后两个属性可选。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">flex: none |  [&lt;&apos;flex-grow&apos;&gt;&lt;&apos;flex-shrink&apos;&gt; ? ||  &lt;&apos;flex-basis&apos;&gt; ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性有两个快捷值： ==auto== (==1 1 auto==) 和 none (==0 0 auto==)。<br>建议优选使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h3 id="4-6-align-self-属性"><a href="#4-6-align-self-属性" class="headerlink" title="4.6 align-self 属性"></a>4.6 align-self 属性</h3><hr><p>==align-self==属性允许单个项目有与其他项目不一样的对齐方式，可覆盖==align-item==属性。默认值为==auto==,表示继承符=父元素的==align-items==属性，如果没有父元素，则等同于==stretch==。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">    align-self: auto | flex-start |  flex-end |  center | baseline | strectch ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下：<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png" alt="enter description here"></p><p>该属性可能取6个值，除了auto,其他都与align-items属性完全一致。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;[TOC]&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;网页布局（layout）是css的一个重点应用。&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://www.ruanyifeng.com/blogimg/asset/2015/bg201507100
      
    
    </summary>
    
      <category term="CSS" scheme="https://wkd709.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://wkd709.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝与浅拷贝</title>
    <link href="https://wkd709.github.io/2018/08/24/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>https://wkd709.github.io/2018/08/24/深拷贝与浅拷贝/</id>
    <published>2018-08-23T16:00:00.000Z</published>
    <updated>2018-08-24T02:35:37.907Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2017/9/3/998e84124743f57f2f7e4005773baa0c?imageslim" alt="深拷贝与浅拷贝"></p><h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p>其实深拷贝和浅拷贝的主要区别就是其在内存中的存储类型不同。</p><p>堆和栈都是内存中划分出来用来存储的区域。</p><blockquote><p>栈（stack）为自动分配的内存空间，它由系统自动释放；而堆（heap）则是动态分配的内存，大小不定也不会自动释放。</p></blockquote><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>基本数据类型主要是：undefined，boolean，number，string，null。</p><p><strong>基本数据类型存放在栈中</strong></p><p>存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配，是直接按值存放的，所以可以直接访问。</p><p><strong>基本数据类型值不可变</strong></p><p>基本数据类型的值是不可变的，动态修改了基本数据类型的值，它的原始值也是不会改变的，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;abc&quot;;</span><br><span class="line"></span><br><span class="line">console.log(str[1]=&quot;f&quot;);    // f</span><br><span class="line"></span><br><span class="line">console.log(str);           // abc</span><br></pre></td></tr></table></figure><p><strong>基本类型的比较是值的比较</strong></p><p>基本类型的比较是值的比较，只要它们的值相等就认为他们是相等的，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line"> var b = 1;</span><br><span class="line"> console.log(a === b);//true</span><br></pre></td></tr></table></figure><p>比较的时候最好使用严格等，因为 == 是会进行类型转换的，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">   var b = true;</span><br><span class="line">   console.log(a == b);//true</span><br></pre></td></tr></table></figure><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p><strong>引用类型存放在堆中</strong></p><p>引用类型（object）是存放在堆内存中的，变量实际上是一个存放在栈内存的指针，这个指针指向堆内存中的地址。每个空间大小不一样，要根据情况开进行特定的分配，例如。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person1 = &#123;name:&apos;jozo&apos;&#125;;</span><br><span class="line">var person2 = &#123;name:&apos;xiaom&apos;&#125;;</span><br><span class="line">var person3 = &#123;name:&apos;xiaoq&apos;&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2017/9/3/6fb2c3d13d830efc6ae07ac368df0816?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="堆内存"></p><p><strong>引用类型值可变</strong></p><p>引用类型是可以直接改变其值的，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3];</span><br><span class="line">a[1] = 5;</span><br><span class="line">console.log(a[1]); // 5</span><br></pre></td></tr></table></figure><p><strong>引用类型的比较是引用的比较</strong></p><p>所以每次我们对 js 中的引用类型进行操作的时候，都是操作其对象的引用（保存在栈内存中的指针），所以比较两个引用类型，是看其的引用是否指向同一个对象。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3];</span><br><span class="line">var b = [1,2,3];</span><br><span class="line">console.log(a === b); // false</span><br></pre></td></tr></table></figure><p>虽然变量 a 和变量 b 都是表示一个内容为 1，2，3 的数组，但是其在内存中的位置不一样，也就是说变量 a 和变量 b 指向的不是同一个对象，所以他们是不相等的。</p><p><img src="https://user-gold-cdn.xitu.io/2017/9/3/a32ee86b9f3e303216d19240441cedfd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="引用类型在内存中的存储"></p><h2 id="传值与传址"><a href="#传值与传址" class="headerlink" title="传值与传址"></a>传值与传址</h2><p>了解了基本数据类型与引用类型的区别之后，我们就应该能明白传值与传址的区别了。<br>在我们进行赋值操作的时候，基本数据类型的赋值（=）是在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">var b = a;</span><br><span class="line"></span><br><span class="line">a ++ ;</span><br><span class="line">console.log(a); // 11</span><br><span class="line">console.log(b); // 10</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2017/9/3/8d973a9718da1806d19db0c1541ff425?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="基本数据类型的赋值"></p><p>所以说，基本类型的赋值的两个变量是两个独立相互不影响的变量。</p><p>是引用类型的赋值是传址。只是改变指针的指向，例如，也就是说引用类型的赋值是对象保存在栈中的地址的赋值，这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;&#125;; // a保存了一个空对象的实例</span><br><span class="line">var b = a;  // a和b都指向了这个空对象</span><br><span class="line"></span><br><span class="line">a.name = &apos;jozo&apos;;</span><br><span class="line">console.log(a.name); // &apos;jozo&apos;</span><br><span class="line">console.log(b.name); // &apos;jozo&apos;</span><br><span class="line"></span><br><span class="line">b.age = 22;</span><br><span class="line">console.log(b.age);// 22</span><br><span class="line">console.log(a.age);// 22</span><br><span class="line"></span><br><span class="line">console.log(a == b);// true</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2017/9/3/01dad9dc00fb0efe81d9bcbe9d30a1bd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="引用类型的赋值"></p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p><strong>赋值（=）和浅拷贝的区别</strong></p><p>深拷贝：将 B 对象拷贝到 A 对象中，包括 B 里面的子对象，</p><p>浅拷贝：将 B 对象拷贝到 A 对象中，但不包括 B 里面的子对象</p><p><img src="./images/拷贝.png" alt=""></p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>深拷贝是对对象以及对象的所有子对象进行拷贝。</p><h2 id="方法（浅拷贝）"><a href="#方法（浅拷贝）" class="headerlink" title="方法（浅拷贝）"></a>方法（浅拷贝）</h2><h3 id="1-Object-assign"><a href="#1-Object-assign" class="headerlink" title="1. Object.assign()"></a>1. Object.assign()</h3><p>es5源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> if (typeof Object.assign != &apos;function&apos;) &#123;</span><br><span class="line">  (function () &#123;</span><br><span class="line">Object.assign = function (target) &#123;</span><br><span class="line"> &apos;use strict&apos;;</span><br><span class="line"> if (target === undefined || target === null) &#123;</span><br><span class="line">   throw new TypeError(&apos;Cannot convert undefined or null to object&apos;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> var output = Object(target);</span><br><span class="line"> for (var index = 1; index &lt; arguments.length; index++) &#123;</span><br><span class="line">   var source = arguments[index];</span><br><span class="line">   if (source !== undefined &amp;&amp; source !== null) &#123;</span><br><span class="line">     for (var nextKey in source) &#123;</span><br><span class="line">       if (source.hasOwnProperty(nextKey)) &#123;</span><br><span class="line">         output[nextKey] = source[nextKey];</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return output;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Object.assign方法用于对象的合并，将源对象（ source ）的所有可枚举属性，复制到目标对象（ target ）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var target = &#123; a: 1 &#125;;</span><br><span class="line">var source1 = &#123; b: 2 &#125;;</span><br><span class="line">var source2 = &#123; c: 3 &#125;;</span><br><span class="line">Object.assign(target, source1, source2);</span><br><span class="line">target // &#123;a:1, b:2, c:3&#125;</span><br></pre></td></tr></table></figure></p><p>Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。</p><p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var target = &#123; a: 1, b: 1 &#125;;</span><br><span class="line">var source1 = &#123; b: 2, c: 2 &#125;;</span><br><span class="line">var source2 = &#123; c: 3 &#125;;</span><br><span class="line">Object.assign(target, source1, source2);</span><br><span class="line">target // &#123;a:1, b:2, c:3&#125;</span><br></pre></td></tr></table></figure><p>如果只有一个参数，Object.assign会直接返回该参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;a: 1&#125;;</span><br><span class="line">Object.assign(obj) === obj // true</span><br></pre></td></tr></table></figure></p><p>如果该参数不是对象，则会先转成对象，然后返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof Object.assign(2) // &quot;object&quot;</span><br></pre></td></tr></table></figure></p><p>由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(undefined) //  报错</span><br><span class="line">Object.assign(null) //  报错</span><br></pre></td></tr></table></figure></p><p>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;a: 1&#125;;</span><br><span class="line">Object.assign(obj, undefined) === obj // true</span><br><span class="line">Object.assign(obj, null) === obj // true</span><br></pre></td></tr></table></figure><p>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var v1 = &apos;abc&apos;;</span><br><span class="line">var v2 = true;</span><br><span class="line">var v3 = 10;</span><br><span class="line">var obj = Object.assign(&#123;&#125;, v1, v2, v3);</span><br><span class="line">console.log(obj); // &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125;</span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li><p>Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。Object.assign()与解构一样，只能深拷贝一级的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;a: &#123;b: 1&#125;&#125;;</span><br><span class="line">var obj2 = Object.assign(&#123;&#125;, obj1);</span><br><span class="line">obj1.a.b = 2;</span><br><span class="line">obj2.a.b // 2</span><br></pre></td></tr></table></figure></li><li><p>对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var target = &#123; a: &#123; b: &apos;c&apos;, d: &apos;e&apos; &#125; &#125;</span><br><span class="line">var source = &#123; a: &#123; b: &apos;hello&apos; &#125; &#125;</span><br><span class="line">Object.assign(target, source)</span><br><span class="line">// &#123; a: &#123; b: &apos;hello&apos; &#125; &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-自定义浅拷贝方法"><a href="#2-自定义浅拷贝方法" class="headerlink" title="2. 自定义浅拷贝方法"></a>2. 自定义浅拷贝方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 浅拷贝实现，仅供参考</span><br><span class="line">function shallowClone(source) &#123;</span><br><span class="line">    if (!source || typeof source !== &apos;object&apos;) &#123;</span><br><span class="line">        throw new Error(&apos;error arguments&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    var targetObj = source.constructor === Array ? [] : &#123;&#125;;</span><br><span class="line">    for (var keys in source) &#123;</span><br><span class="line">        if (source.hasOwnProperty(keys)) &#123;</span><br><span class="line">            targetObj[keys] = source[keys];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return targetObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法-（深拷贝）："><a href="#方法-（深拷贝）：" class="headerlink" title="方法 （深拷贝）："></a>方法 （深拷贝）：</h2><h3 id="1-JSON字符串"><a href="#1-JSON字符串" class="headerlink" title="1. JSON字符串"></a>1. JSON字符串</h3><p>使用JSON字符串进行深拷贝，多层嵌套对象也可以进行深拷贝<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;a:&apos;123&apos;,b:&#123;c:&apos;333&apos;&#125;&#125;</span><br><span class="line">var b = JSON.parse(JSON.stringify(a));</span><br><span class="line">b.a = &apos;yyy&apos;</span><br><span class="line">b.b.c =222;</span><br><span class="line">console.log(a.a); // 123</span><br><span class="line">console.log(a.b.c); // 333</span><br></pre></td></tr></table></figure></p><p>可以封装如下函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var cloneObj = function(obj)&#123;</span><br><span class="line">    var str, newobj = obj.constructor === Array ? [] : &#123;&#125;;</span><br><span class="line">    if(typeof obj !== &apos;object&apos;)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125; else if(window.JSON)&#123;</span><br><span class="line">        str = JSON.stringify(obj), //系列化对象</span><br><span class="line">        newobj = JSON.parse(str); //还原</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for(var i in obj)&#123;</span><br><span class="line">            newobj[i] = typeof obj[i] === &apos;object&apos; ? </span><br><span class="line">            cloneObj(obj[i]) : obj[i]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-jQuery-extend-方法源码实现"><a href="#2-jQuery-extend-方法源码实现" class="headerlink" title="2. jQuery.extend()方法源码实现"></a>2. jQuery.extend()方法源码实现</h3><p>源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend = jQuery.fn.extend = function() &#123; //给jQuery对象和jQuery原型对象都添加了extend扩展方法</span><br><span class="line">  var options, name, src, copy, copyIsArray, clone, target = arguments[0] || &#123;&#125;,</span><br><span class="line">  i = 1,</span><br><span class="line">  length = arguments.length,</span><br><span class="line">  deep = false;</span><br><span class="line">  //以上其中的变量：options是一个缓存变量，用来缓存arguments[i]，name是用来接收将要被扩展对象的key，src改变之前target对象上每个key对应的value。</span><br><span class="line">  //copy传入对象上每个key对应的value，copyIsArray判定copy是否为一个数组，clone深拷贝中用来临时存对象或数组的src。</span><br><span class="line"></span><br><span class="line">  // 处理深拷贝的情况</span><br><span class="line">  if (typeof target === &quot;boolean&quot;) &#123;</span><br><span class="line">    deep = target;</span><br><span class="line">    target = arguments[1] || &#123;&#125;;</span><br><span class="line">    //跳过布尔值和目标 </span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 控制当target不是object或者function的情况</span><br><span class="line">  if (typeof target !== &quot;object&quot; &amp;&amp; !jQuery.isFunction(target)) &#123;</span><br><span class="line">    target = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 当参数列表长度等于i的时候，扩展jQuery对象自身。</span><br><span class="line">  if (length === i) &#123;</span><br><span class="line">    target = this; --i;</span><br><span class="line">  &#125;</span><br><span class="line">  for (; i &lt; length; i++) &#123;</span><br><span class="line">    if ((options = arguments[i]) != null) &#123;</span><br><span class="line">      // 扩展基础对象</span><br><span class="line">      for (name in options) &#123;</span><br><span class="line">        src = target[name];</span><br><span class="line">        copy = options[name];</span><br><span class="line"></span><br><span class="line">        // 防止永无止境的循环，这里举个例子，</span><br><span class="line">            // 如 var a = &#123;name : b&#125;;</span><br><span class="line">            // var b = &#123;name : a&#125;</span><br><span class="line">            // var c = $.extend(a, b);</span><br><span class="line">            // console.log(c);</span><br><span class="line">            // 如果没有这个判断变成可以无限展开的对象</span><br><span class="line">            // 加上这句判断结果是 &#123;name: undefined&#125;</span><br><span class="line">        if (target === copy) &#123;</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) &#123;</span><br><span class="line">          if (copyIsArray) &#123;</span><br><span class="line">            copyIsArray = false;</span><br><span class="line">            clone = src &amp;&amp; jQuery.isArray(src) ? src: []; // 如果src存在且是数组的话就让clone副本等于src否则等于空数组。</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            clone = src &amp;&amp; jQuery.isPlainObject(src) ? src: &#123;&#125;; // 如果src存在且是对象的话就让clone副本等于src否则等于空数组。</span><br><span class="line">          &#125;</span><br><span class="line">          // 递归拷贝</span><br><span class="line">          target[name] = jQuery.extend(deep, clone, copy);</span><br><span class="line">        &#125; else if (copy !== undefined) &#123;</span><br><span class="line">          target[name] = copy; // 若原对象存在name属性，则直接覆盖掉；若不存在，则创建新的属性。</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 返回修改的对象</span><br><span class="line">  return target;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>jQuery的extend方法使用基本的递归思路实现了浅拷贝和深拷贝，但是这个方法也无法处理源对象内部循环引用，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;&quot;name&quot;:&quot;aaa&quot;&#125;;</span><br><span class="line">var b = &#123;&quot;name&quot;:&quot;bbb&quot;&#125;;</span><br><span class="line">a.child = b;</span><br><span class="line">b.parent = a;</span><br><span class="line">$.extend(true,&#123;&#125;,a);//直接报了栈溢出。Uncaught RangeError: Maximum call stack size exceeded</span><br></pre></td></tr></table></figure><h3 id="3-自定义深拷贝方法"><a href="#3-自定义深拷贝方法" class="headerlink" title="3. 自定义深拷贝方法"></a>3. 自定义深拷贝方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 递归实现一个深拷贝</span><br><span class="line">function deepClone(source)&#123;</span><br><span class="line">   if(!source || typeof source !== &apos;object&apos;)&#123;</span><br><span class="line">     throw new Error(&apos;error arguments&apos;, &apos;shallowClone&apos;);</span><br><span class="line">   &#125;</span><br><span class="line">   var targetObj = source.constructor === Array ? [] : &#123;&#125;;</span><br><span class="line">   for(var keys in source)&#123;</span><br><span class="line">      if(source.hasOwnProperty(keys))&#123;</span><br><span class="line">         if(source[keys] &amp;&amp; typeof source[keys] === &apos;object&apos;)&#123;</span><br><span class="line">           targetObj[keys] = source[keys].constructor === Array ? [] : &#123;&#125;;</span><br><span class="line">           targetObj[keys] = deepClone(source[keys]);</span><br><span class="line">         &#125;else&#123;</span><br><span class="line">           targetObj[keys] = source[keys];</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; </span><br><span class="line">   &#125;</span><br><span class="line">   return targetObj;</span><br><span class="line">&#125;</span><br><span class="line">// test example</span><br><span class="line">var o1 = &#123;</span><br><span class="line">  arr: [1, 2, 3],</span><br><span class="line">  obj: &#123;</span><br><span class="line">    key: &apos;value&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  func: function()&#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var o3 = deepClone(o1);</span><br><span class="line">console.log(o3 === o1); // =&gt; false</span><br><span class="line">console.log(o3.obj === o1.obj); // =&gt; false</span><br><span class="line">console.log(o2.func === o1.func); // =&gt; true</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/9/3/998e84124743f57f2f7e4005773baa0c?imageslim&quot; alt=&quot;深拷贝与浅拷贝&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;堆和栈的区别&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://wkd709.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://wkd709.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>

{"meta":{"title":"wkd709个人网站","subtitle":null,"description":"wkd709个人网站","author":"wkd709","url":"https://wkd709.github.io"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-08-23T08:47:42.651Z","updated":"2018-08-23T08:47:42.651Z","comments":false,"path":"/404.html","permalink":"https://wkd709.github.io//404.html","excerpt":"","text":""},{"title":"关于","date":"2018-08-23T08:47:42.652Z","updated":"2018-08-23T08:47:42.652Z","comments":false,"path":"about/index.html","permalink":"https://wkd709.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2018-08-23T08:47:42.653Z","updated":"2018-08-23T08:47:42.653Z","comments":false,"path":"books/index.html","permalink":"https://wkd709.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-08-24T02:22:49.862Z","updated":"2018-08-24T02:22:49.862Z","comments":false,"path":"categories/index.html","permalink":"https://wkd709.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-08-23T08:47:42.654Z","updated":"2018-08-23T08:47:42.654Z","comments":true,"path":"links/index.html","permalink":"https://wkd709.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-08-23T08:47:42.655Z","updated":"2018-08-23T08:47:42.655Z","comments":false,"path":"tags/index.html","permalink":"https://wkd709.github.io/tags/index.html","excerpt":"","text":""},{"title":"项目","date":"2018-08-23T10:03:38.836Z","updated":"2018-08-23T10:03:38.836Z","comments":false,"path":"repository/index.html","permalink":"https://wkd709.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"flex布局","slug":"flex布局","date":"2018-08-23T16:00:00.000Z","updated":"2018-08-24T02:20:47.578Z","comments":true,"path":"2018/08/24/flex布局/","link":"","permalink":"https://wkd709.github.io/2018/08/24/flex布局/","excerpt":"","text":"[TOC] 网页布局（layout）是css的一个重点应用。 布局的传统解决方案，基于盒状模型，依赖==display==属性 + ==float==属性。它对于那些特殊布局非常不便，比如，==垂直居中==就不容易实现。 各大浏览器的兼容性如下: 一、Flex布局是什么？ Flex是Flexible Box 的缩写，意为’弹性布局’，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。 123.box &#123; display: block;&#125; 行内元素也可以使用Flex布局。 123.box &#123; display: inline-flex;&#125; webkit内核的浏览器，必须加上 ==-webkit-== 前缀。 1234.box &#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意：，设为Flex布局以后，子元素的 ==float==、==clear==和==vertical-aligin==属性将失效。 二、基本概念 采用Flex布局的元素，称为Flex容器（flex container),简称“容器”。它的所有子元素自动称为容器成员，称为Flex项目（flex item),简称“项目”。 容器默认存在两根轴：水平的主轴（main axis)。主轴的开始位置（与边框的交叉点）叫做==main start==，结束位置叫做 ==main end==;交叉轴的开始位置叫做==cross start==，结束位置叫做==cross end==。 项目默认沿主轴排列。单个项目占据的主轴空间叫做==main size==,占据的交叉轴空间叫做==cross size==。 三、容器的属性 以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content 3.1 flex-direction flex-direction 属性决定主轴的方向（即项目的排列方向）。 123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 四种： 它可能有4个值。 row (默认值)： 主轴为水平方向，起点在左端。 row-reverse： 主轴为水平方向，起点在右端。 column： 主轴为垂直方向，起点在上沿。 column-reverse： 主轴为垂直方向，起点在下沿。 3.2 flex-wrap属性 默认情况下，项目都排在一条线（又称‘轴线’）上。==flex-wrap==属性定义，如果一条轴线排不下，如何换行。 123.box &#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值。（1）、==nowrap==（默认）： 不换行 （2）、==wrap==：换行，第一行在上方。 （3）、==wrap-reverse==：换行，第一行在下方。 3.3 flex-flow 123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; 3.4 justify-content属性 ==justify-content==属性定义了项目在主轴上的对齐方式。123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 以下： 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start (默认值) : 左对齐 flex-end : 右对齐 center ： 居中 space-between : 两端对齐，项目之前的间隔都相等。 space-around : 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 3.5 align-items属性 ==alig-items==属性定义项目在交叉轴上如何对齐。123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 以下： 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline：项目的第一行文字的基线对齐。 stretch （默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content 属性 ==align-content==属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。123.box &#123; align-content : flex-start | flex-end | center | space-between | space-around&#125; 以下： 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch （默认值）：轴线占满整个交叉轴。 四、项目的属性 以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 4.1 order属性 ==order==属性定义项目的排列顺序。数值越小，排列越靠前，默认为0； 123.item &#123; order: &lt;integer&gt;;&#125; 以下: 4.2 flex-grow属性 ==flex-grow==属性定义项目的放大比例，默认为==0==，即如果存在剩余空间，也不放大。 123.item &#123; flex-grow: &lt;number&gt;; /* default 0*/&#125; 以下： 如果所有项目的==flex-grow==属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的==flex-grow==属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性 ==flex-shrink==属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1*/;&#125; 以下： 如果所有项目的==flex-shrink==属性都为1，当空间不足时，都将等比缩小。如果一个项目的==flex-shrink==属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 4.4 flex-basis属性 ==flex-basis==属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否多余空间。它的默认值为==auto==,即项目的本来大小。 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟==width==或==height==属性一样的值（比如350px）,则项目占据固定空间。 4.5 flex属性 ==flex==属性是==flex-grow==,==flex-shrink==和==flex-basis==的简写，默认值为==0 1 auto==。后两个属性可选。 123.item &#123;flex: none | [&lt;&apos;flex-grow&apos;&gt;&lt;&apos;flex-shrink&apos;&gt; ? || &lt;&apos;flex-basis&apos;&gt; ] &#125; 属性有两个快捷值： ==auto== (==1 1 auto==) 和 none (==0 0 auto==)。建议优选使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self 属性 ==align-self==属性允许单个项目有与其他项目不一样的对齐方式，可覆盖==align-item==属性。默认值为==auto==,表示继承符=父元素的==align-items==属性，如果没有父元素，则等同于==stretch==。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | strectch ;&#125; 以下： 该属性可能取6个值，除了auto,其他都与align-items属性完全一致。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://wkd709.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://wkd709.github.io/tags/CSS/"}]},{"title":"深拷贝与浅拷贝","slug":"深拷贝与浅拷贝","date":"2018-08-23T16:00:00.000Z","updated":"2018-08-24T02:35:37.907Z","comments":true,"path":"2018/08/24/深拷贝与浅拷贝/","link":"","permalink":"https://wkd709.github.io/2018/08/24/深拷贝与浅拷贝/","excerpt":"","text":"堆和栈的区别其实深拷贝和浅拷贝的主要区别就是其在内存中的存储类型不同。 堆和栈都是内存中划分出来用来存储的区域。 栈（stack）为自动分配的内存空间，它由系统自动释放；而堆（heap）则是动态分配的内存，大小不定也不会自动释放。 基本数据类型基本数据类型主要是：undefined，boolean，number，string，null。 基本数据类型存放在栈中 存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配，是直接按值存放的，所以可以直接访问。 基本数据类型值不可变 基本数据类型的值是不可变的，动态修改了基本数据类型的值，它的原始值也是不会改变的，例如 12345var str = &quot;abc&quot;;console.log(str[1]=&quot;f&quot;); // fconsole.log(str); // abc 基本类型的比较是值的比较 基本类型的比较是值的比较，只要它们的值相等就认为他们是相等的，例如： 123var a = 1; var b = 1; console.log(a === b);//true 比较的时候最好使用严格等，因为 == 是会进行类型转换的，比如： 123var a = 1; var b = true; console.log(a == b);//true 引用类型引用类型存放在堆中 引用类型（object）是存放在堆内存中的，变量实际上是一个存放在栈内存的指针，这个指针指向堆内存中的地址。每个空间大小不一样，要根据情况开进行特定的分配，例如。 123var person1 = &#123;name:&apos;jozo&apos;&#125;;var person2 = &#123;name:&apos;xiaom&apos;&#125;;var person3 = &#123;name:&apos;xiaoq&apos;&#125;; 引用类型值可变 引用类型是可以直接改变其值的，例如： 123var a = [1,2,3];a[1] = 5;console.log(a[1]); // 5 引用类型的比较是引用的比较 所以每次我们对 js 中的引用类型进行操作的时候，都是操作其对象的引用（保存在栈内存中的指针），所以比较两个引用类型，是看其的引用是否指向同一个对象。例如： 123var a = [1,2,3];var b = [1,2,3];console.log(a === b); // false 虽然变量 a 和变量 b 都是表示一个内容为 1，2，3 的数组，但是其在内存中的位置不一样，也就是说变量 a 和变量 b 指向的不是同一个对象，所以他们是不相等的。 传值与传址了解了基本数据类型与引用类型的区别之后，我们就应该能明白传值与传址的区别了。在我们进行赋值操作的时候，基本数据类型的赋值（=）是在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中。例如： 123456var a = 10;var b = a;a ++ ;console.log(a); // 11console.log(b); // 10 所以说，基本类型的赋值的两个变量是两个独立相互不影响的变量。 是引用类型的赋值是传址。只是改变指针的指向，例如，也就是说引用类型的赋值是对象保存在栈中的地址的赋值，这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响。例如： 123456789101112var a = &#123;&#125;; // a保存了一个空对象的实例var b = a; // a和b都指向了这个空对象a.name = &apos;jozo&apos;;console.log(a.name); // &apos;jozo&apos;console.log(b.name); // &apos;jozo&apos;b.age = 22;console.log(b.age);// 22console.log(a.age);// 22console.log(a == b);// true 浅拷贝赋值（=）和浅拷贝的区别 深拷贝：将 B 对象拷贝到 A 对象中，包括 B 里面的子对象， 浅拷贝：将 B 对象拷贝到 A 对象中，但不包括 B 里面的子对象 深拷贝深拷贝是对对象以及对象的所有子对象进行拷贝。 方法（浅拷贝）1. Object.assign()es5源码：1234567891011121314151617181920212223 if (typeof Object.assign != &apos;function&apos;) &#123; (function () &#123; Object.assign = function (target) &#123; &apos;use strict&apos;; if (target === undefined || target === null) &#123; throw new TypeError(&apos;Cannot convert undefined or null to object&apos;); &#125; var output = Object(target); for (var index = 1; index &lt; arguments.length; index++) &#123; var source = arguments[index]; if (source !== undefined &amp;&amp; source !== null) &#123; for (var nextKey in source) &#123; if (source.hasOwnProperty(nextKey)) &#123; output[nextKey] = source[nextKey]; &#125; &#125; &#125; &#125; return output; &#125;;&#125;)();&#125; Object.assign方法用于对象的合并，将源对象（ source ）的所有可枚举属性，复制到目标对象（ target ）。12345var target = &#123; a: 1 &#125;;var source1 = &#123; b: 2 &#125;;var source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。 注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 12345var target = &#123; a: 1, b: 1 &#125;;var source1 = &#123; b: 2, c: 2 &#125;;var source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 如果只有一个参数，Object.assign会直接返回该参数。12var obj = &#123;a: 1&#125;;Object.assign(obj) === obj // true 如果该参数不是对象，则会先转成对象，然后返回。1typeof Object.assign(2) // &quot;object&quot; 由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。12Object.assign(undefined) // 报错Object.assign(null) // 报错 如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错。 123let obj = &#123;a: 1&#125;;Object.assign(obj, undefined) === obj // trueObject.assign(obj, null) === obj // true 其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。 12345var v1 = &apos;abc&apos;;var v2 = true;var v3 = 10;var obj = Object.assign(&#123;&#125;, v1, v2, v3);console.log(obj); // &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125; 注意点： Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。Object.assign()与解构一样，只能深拷贝一级的对象。 1234var obj1 = &#123;a: &#123;b: 1&#125;&#125;;var obj2 = Object.assign(&#123;&#125;, obj1);obj1.a.b = 2;obj2.a.b // 2 对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。 1234var target = &#123; a: &#123; b: &apos;c&apos;, d: &apos;e&apos; &#125; &#125;var source = &#123; a: &#123; b: &apos;hello&apos; &#125; &#125;Object.assign(target, source)// &#123; a: &#123; b: &apos;hello&apos; &#125; &#125; 2. 自定义浅拷贝方法12345678910111213// 浅拷贝实现，仅供参考function shallowClone(source) &#123; if (!source || typeof source !== &apos;object&apos;) &#123; throw new Error(&apos;error arguments&apos;); &#125; var targetObj = source.constructor === Array ? [] : &#123;&#125;; for (var keys in source) &#123; if (source.hasOwnProperty(keys)) &#123; targetObj[keys] = source[keys]; &#125; &#125; return targetObj;&#125; 方法 （深拷贝）：1. JSON字符串使用JSON字符串进行深拷贝，多层嵌套对象也可以进行深拷贝123456var a = &#123;a:&apos;123&apos;,b:&#123;c:&apos;333&apos;&#125;&#125;var b = JSON.parse(JSON.stringify(a));b.a = &apos;yyy&apos;b.b.c =222;console.log(a.a); // 123console.log(a.b.c); // 333 可以封装如下函数 123456789101112131415var cloneObj = function(obj)&#123; var str, newobj = obj.constructor === Array ? [] : &#123;&#125;; if(typeof obj !== &apos;object&apos;)&#123; return; &#125; else if(window.JSON)&#123; str = JSON.stringify(obj), //系列化对象 newobj = JSON.parse(str); //还原 &#125; else &#123; for(var i in obj)&#123; newobj[i] = typeof obj[i] === &apos;object&apos; ? cloneObj(obj[i]) : obj[i]; &#125; &#125; return newobj;&#125;; 2. jQuery.extend()方法源码实现源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960jQuery.extend = jQuery.fn.extend = function() &#123; //给jQuery对象和jQuery原型对象都添加了extend扩展方法 var options, name, src, copy, copyIsArray, clone, target = arguments[0] || &#123;&#125;, i = 1, length = arguments.length, deep = false; //以上其中的变量：options是一个缓存变量，用来缓存arguments[i]，name是用来接收将要被扩展对象的key，src改变之前target对象上每个key对应的value。 //copy传入对象上每个key对应的value，copyIsArray判定copy是否为一个数组，clone深拷贝中用来临时存对象或数组的src。 // 处理深拷贝的情况 if (typeof target === &quot;boolean&quot;) &#123; deep = target; target = arguments[1] || &#123;&#125;; //跳过布尔值和目标 i++; &#125; // 控制当target不是object或者function的情况 if (typeof target !== &quot;object&quot; &amp;&amp; !jQuery.isFunction(target)) &#123; target = &#123;&#125;; &#125; // 当参数列表长度等于i的时候，扩展jQuery对象自身。 if (length === i) &#123; target = this; --i; &#125; for (; i &lt; length; i++) &#123; if ((options = arguments[i]) != null) &#123; // 扩展基础对象 for (name in options) &#123; src = target[name]; copy = options[name]; // 防止永无止境的循环，这里举个例子， // 如 var a = &#123;name : b&#125;; // var b = &#123;name : a&#125; // var c = $.extend(a, b); // console.log(c); // 如果没有这个判断变成可以无限展开的对象 // 加上这句判断结果是 &#123;name: undefined&#125; if (target === copy) &#123; continue; &#125; if (deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) &#123; if (copyIsArray) &#123; copyIsArray = false; clone = src &amp;&amp; jQuery.isArray(src) ? src: []; // 如果src存在且是数组的话就让clone副本等于src否则等于空数组。 &#125; else &#123; clone = src &amp;&amp; jQuery.isPlainObject(src) ? src: &#123;&#125;; // 如果src存在且是对象的话就让clone副本等于src否则等于空数组。 &#125; // 递归拷贝 target[name] = jQuery.extend(deep, clone, copy); &#125; else if (copy !== undefined) &#123; target[name] = copy; // 若原对象存在name属性，则直接覆盖掉；若不存在，则创建新的属性。 &#125; &#125; &#125; &#125; // 返回修改的对象 return target;&#125;; jQuery的extend方法使用基本的递归思路实现了浅拷贝和深拷贝，但是这个方法也无法处理源对象内部循环引用，例如： 12345var a = &#123;&quot;name&quot;:&quot;aaa&quot;&#125;;var b = &#123;&quot;name&quot;:&quot;bbb&quot;&#125;;a.child = b;b.parent = a;$.extend(true,&#123;&#125;,a);//直接报了栈溢出。Uncaught RangeError: Maximum call stack size exceeded 3. 自定义深拷贝方法1234567891011121314151617181920212223242526272829303132// 递归实现一个深拷贝function deepClone(source)&#123; if(!source || typeof source !== &apos;object&apos;)&#123; throw new Error(&apos;error arguments&apos;, &apos;shallowClone&apos;); &#125; var targetObj = source.constructor === Array ? [] : &#123;&#125;; for(var keys in source)&#123; if(source.hasOwnProperty(keys))&#123; if(source[keys] &amp;&amp; typeof source[keys] === &apos;object&apos;)&#123; targetObj[keys] = source[keys].constructor === Array ? [] : &#123;&#125;; targetObj[keys] = deepClone(source[keys]); &#125;else&#123; targetObj[keys] = source[keys]; &#125; &#125; &#125; return targetObj;&#125;// test examplevar o1 = &#123; arr: [1, 2, 3], obj: &#123; key: &apos;value&apos; &#125;, func: function()&#123; return 1; &#125;&#125;;var o3 = deepClone(o1);console.log(o3 === o1); // =&gt; falseconsole.log(o3.obj === o1.obj); // =&gt; falseconsole.log(o2.func === o1.func); // =&gt; true","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wkd709.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wkd709.github.io/tags/JavaScript/"}]}]}
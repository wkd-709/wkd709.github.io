{"meta":{"title":"wkd709个人网站","subtitle":null,"description":"wkd709个人网站","author":"wkd709","url":"https://wkd709.github.io"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-08-23T08:47:42.651Z","updated":"2018-08-23T08:47:42.651Z","comments":false,"path":"/404.html","permalink":"https://wkd709.github.io//404.html","excerpt":"","text":""},{"title":"关于","date":"2018-08-23T08:47:42.652Z","updated":"2018-08-23T08:47:42.652Z","comments":false,"path":"about/index.html","permalink":"https://wkd709.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2018-08-23T08:47:42.653Z","updated":"2018-08-23T08:47:42.653Z","comments":false,"path":"books/index.html","permalink":"https://wkd709.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-08-24T02:22:49.862Z","updated":"2018-08-24T02:22:49.862Z","comments":false,"path":"categories/index.html","permalink":"https://wkd709.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-08-23T08:47:42.654Z","updated":"2018-08-23T08:47:42.654Z","comments":true,"path":"links/index.html","permalink":"https://wkd709.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-08-23T08:47:42.655Z","updated":"2018-08-23T08:47:42.655Z","comments":false,"path":"tags/index.html","permalink":"https://wkd709.github.io/tags/index.html","excerpt":"","text":""},{"title":"项目","date":"2018-08-23T10:03:38.836Z","updated":"2018-08-23T10:03:38.836Z","comments":false,"path":"repository/index.html","permalink":"https://wkd709.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"常见的浏览器内核","slug":"常见的浏览器内核","date":"2018-08-23T16:00:00.000Z","updated":"2018-08-24T02:44:05.359Z","comments":true,"path":"2018/08/24/常见的浏览器内核/","link":"","permalink":"https://wkd709.github.io/2018/08/24/常见的浏览器内核/","excerpt":"","text":"常用浏览器及内核如下： 使用Trident内核的浏览器：IE、Maxthon、TT、The World，360的兼容模式和IE模式等； 使用Gecko内核的浏览器：Netcape6及以上版本、FireFox、MozillaSuite/SeaMonkey； 使用Presto内核的浏览器：Opera7及以上版本； 使用Webkit内核的浏览器：Safari、Chrome。360的极速模式等 Trident 内核代表产品Internet Explorer，又称其为IE内核。 Trident内核的常见浏览器有： （1）IE6、IE7、IE8（Trident 4.0）、IE9（Trident 5.0）、IE10（Trident 6.0）； （2）猎豹安全浏览器：1.0-4.2版本为Trident+Webkit，4.3版本为Trident+Blink； （3）360安全浏览器 ：1.0-5.0为Trident，6.0为Trident+Webkit，7.0为Trident+Blink； （4）360极速浏览器：7.5之前为Trident+Webkit,7.5为Trident+Blink； （5）傲游浏览器 ：傲游1.x、2.x为IE内核，3.x为IE与Webkit双核； （6）搜狗高速浏览器：1.x为Trident，2.0及以后版本为Trident+Webkit；","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://wkd709.github.io/categories/浏览器/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://wkd709.github.io/tags/浏览器/"}]},{"title":"浏览器缓存机制","slug":"浏览器缓存机制","date":"2018-08-23T16:00:00.000Z","updated":"2018-08-24T02:43:32.792Z","comments":true,"path":"2018/08/24/浏览器缓存机制/","link":"","permalink":"https://wkd709.github.io/2018/08/24/浏览器缓存机制/","excerpt":"","text":"注意，我们讨论的所有关于缓存资源的问题，都仅仅针对GET请求。而对于POST, DELETE, PUT这类行为性操作通常不做任何缓存。 浏览器缓存的作用？ 加快页面打开速度 降低服务器压力 减少网络损耗 浏览器缓存有 HTML Meta 标签 控制与 HTTP 头信息控制两种。 一、html meta标签控制1&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt; 上述代码的作用是告诉浏览器当前页面不被缓存，所以每当需要请求该页面时都需要去服务器获取。 但由于仅有部分浏览器支持该标签，并且所有的缓存代理服务器均不支持，所以并未被广泛使用。 二、HTTP头信息控制对于每次浏览器第一次HTTP请求来说，浏览器缓存中并不存在其请求资源相应的副本，这是浏览器便会向服务器发出HTTP请求来获取相应的请求结果，并根据缓存标识字段，来决定是否将请求结果作为副本存入浏览器缓存中。 HTTP 保持已缓存数据与服务器数据之间充分一致的机制称为文档过期和服务器再验证。而从浏览器缓存分类来看，也有将其分为强制缓存和协商缓存。 文档过期当浏览器发起 HTTP 请求时，会根据浏览器缓存中的缓存标识字段来验证文档（资源副本）是否过期。上述说的缓存标识字段便是 Expires 和 Cache-Control。 Expires 是服务器端在响应请求时用来规定资源的失效时间。 Cache-Control是服务器端在响应请求时用来规定资源是否需要被浏览器缓存以及缓存的有效时间等。 Cache-Control 主要取值如下： public：所有内容都将被缓存（客户端和代理服务器都可缓存） private：内容只缓存到私有缓存中（仅客户端可以缓存，代理服务器不可缓存） no-cache：必须先与服务器确认返回的响应是否被更改，然后才能使用该响应来满足后续对同一个网址的请求。因此，如果存在合适的验证令牌（ETag），no-cache 会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载 no-store：所有内容都不会被缓存或 Internet 临时文件中 must-revalidation/proxy-revalidation：如果缓存的内容失效，请求必须发送到服务器/代理以进行重新验证 max-age=xxx：缓存的内容将在 xxx 秒后失效 这里需要注意的是，no-cache 的作用是指跳过文档过期的验证而直接进行服务器再验证，而 no-store 是指资源禁止被缓存。 服务器再验证在浏览器缓存中，还保存了其它关于资源副本的描述字段，这些字段都是服务器返回信息头带过来的，如 Last-Modified 和 Etag。 Last-Modified 是服务器端在响应请求时用来说明资源的最后修改时间。与之对应的是 If-Modified-Since 字段，在服务器再验证过程中，浏览器发送的 HTTP 请求的请求头中会带上 If-Modified-Since 字段，值为该资源 Last-Modified 属性的值。当服务器端接收到带有 If-Modified-Since 属性的请求时，则会将 If-Modified-Since 属性的值与被请求资源的最后修改时间做对比。如果相同，说明资源没有新的修改，则响应 HTTP 304，浏览器会继续使用原先保存的该资源的副本；如果最后修改时间比较新，则说明资源被修改过，则响应 HTTP 200，并且返回最新的资源。 Etag 是服务器端在响应请求时用来说明资源在服务器端的唯一标识。与之对应的是 If-None-Match 字段，在服务器再验证过程中，浏览器发送的 HTTP 请求的请求头中会带上 If-Modified-Since 字段，值为该资源 Etag 属性的值。 三、浏览器行为引起的不同浏览器的行为会产生怎样的请求： 刷新网页 =&gt; 如果缓存没有失效，浏览器会直接使用缓存；反之，则向服务器请求数据 手动刷新（F5） =&gt; 浏览器会认为缓存失效，在请求服务器时加上Cache-Control: max-age=0字段，然后询问服务器数据是否更新。 强制刷新（Ctrl + F5） =&gt; 浏览器会直接忽略缓存，在请求服务器时加上Cache-Control: no-cache字段，然后重新向服务器拉取文件。","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://wkd709.github.io/categories/浏览器/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://wkd709.github.io/tags/浏览器/"}]},{"title":"HTML head 头标签","slug":"HTML_head_头部标签","date":"2018-08-23T16:00:00.000Z","updated":"2018-08-24T02:44:48.282Z","comments":true,"path":"2018/08/24/HTML_head_头部标签/","link":"","permalink":"https://wkd709.github.io/2018/08/24/HTML_head_头部标签/","excerpt":"","text":"HTML head 头部分的标签、元素有很多，涉及到浏览器对网页的渲染，SEO 等等，而各个浏览器内核以及各个国内浏览器厂商都有些自己的标签元素,这就造成了很多差异性。移动互联网时代，head 头部结构，移动端的 meta 元素，显得更为重要。了解每个标签的意义，写出满足自己需求的 head 头标签。 一、 DOCTYPE DOCTYPE(Document Type)，该声明位于文档中最前面的位置，处于 html 标签之前，此标签告知浏览器文档使用哪种 HTML 或者 XHTML 规范。DTD(Document Type Definition) 声明以 &lt;!DOCTYPE&gt; 开始，不区分大小写，前面没有任何内容，如果有其他内容(空格除外)会使浏览器在 IE 下开启怪异模式(quirks mode)渲染网页。公共 DTD，名称格式为注册//组织//类型 标签//语言,注册指组织是否由国际标准化组织(ISO)注册，+表示是，-表示不是。组织即组织名称，如：W3C。类型一般是 DTD。标签是指定公开文本描述，即对所引用的公开文本的唯一描述性名称，后面可附带版本号。最后语言是 DTD 语言的 ISO 639 语言标识符，如：EN 表示英文，ZH 表示中文。XHTML 1.0 可声明三种 DTD 类型。分别表示严格版本，过渡版本，以及基于框架的 HTML 文档。 最新 HTML5 推出更加简洁的书写，它向前向后兼容，推荐使用。 ==&lt;!doctype html&gt;== 在 HTML中 doctype 有两个主要目的。 对文档进行有效性验证。 它告诉用户代理和校验器这个文档是按照什么 DTD 写的。这个动作是被动的，每次页面加载时，浏览器并不会下载 DTD 并检查合法性，只有当手动校验页面时才启用。 决定浏览器的呈现模式 对于实际操作，通知浏览器读取文档时用哪种解析算法。如果没有写，则浏览器则根据自身的规则对代码进行解析，可能会严重影响 html 排版布局。浏览器有三种方式解析 HTML 文档。 非怪异（标准）模式 怪异模式 * 部分怪异（近乎标准）模式 关于IE浏览器的文档模式，浏览器模式，严格模式，怪异模式，DOCTYPE 标签，可详细阅读模式？标准！的内容。 langth属性 简体中文 1&lt;html lang=\"zh-cmn-Hans\"&gt; 繁体中文 1&lt;html lang=\"zh-cmn-Hant\"&gt; 常用写法： 123&lt;html lang=\"zh\"&gt;&lt;html lang=\"zh-CN\"&gt; favicon icon 12&lt;link rel=\"shortcut icon\" type=\"image/ico\" href=\"/favicon.ico\" /&gt;&lt;!-- 添加 favicon icon --&gt; 二、 meta 元素 （常见的一些用法） 标签提供关于html文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或者重新加载页面），搜索引擎（关键词），或其他web服务。 meta标签共两个属性，分别是http-equiv属性和name属性。 1. name属性name属性主要用于描述网页。比如网页的关键词，叙述等。与之对应的属性值为content，content中的内容是对name填入类型的具体描述，便于搜索引擎抓取。meta标签中name属性语法格式为： 1&lt;meta name =&apos;参数&apos; content=&apos;具体的描述&apos;&gt; 其中name属性共有以下几种参数（A-C为常用属性） A. keywords(关键字） 说明：用于告诉搜索引擎，你网页的关键字。 举例： 1&lt;meta name=&quot;keywords&quot; content=&quot;Lxxyx,博客，文科生，前端&quot;&gt; B. description(网站内容的描述) 说明：用于告诉搜索引擎，你网站的主要内容。 1&lt;meta name=&quot;description&quot; content=&quot;文科生，热爱前端与编程。目前大二，这是我的前端博客&quot;&gt; C. robots(定义搜索引擎爬虫的索引方式) 说明：robots用来告诉爬虫哪些页面需要索引，哪些页面不需要索引。 content的参数有all,none,index,noindex,follow,nofollow。默认是all。 举例： 1&lt;meta name=&quot;robots&quot; content=&quot;none&quot;&gt; 具体参数如下： 1.none : 搜索引擎将忽略此网页，等价于noindex，nofollow。 2.noindex : 搜索引擎不索引此网页。 3.nofollow: 搜索引擎不继续通过此网页的链接索引搜索其它的网页。 4.all : 搜索引擎将索引此网页与继续通过此网页的链接索引，等价于index，follow。 5.index : 搜索引擎索引此网页。 6.follow : 搜索引擎继续通过此网页的链接索引搜索其它的网页。 D. author(作者) 说明：用于标注网页作者举例： 1&lt;meta name=\"author\" content=\"Lxxyx,841380530@qq.com\"&gt; E. generator(网页制作软件) F. copyright(版权) 说明：用于标注版权信息举例： 1&lt;meta name=\"copyright\" content=\"Lxxyx\"&gt; //代表该网站为Lxxyx个人版权所有。 G. revisit-after (搜索引擎爬虫重访时间) 说明：如果页面不是经常更新，为了减轻搜索引擎爬虫对服务器带来的压力，可以设置一个爬虫的重访时间。如果重访时间过短，爬虫将按它们定义的默认时间来访问。举例： 1&lt;meta name=\"revisit-after\" content=\"7 days\" &gt; H renderer(双核浏览器渲染方式) 说明：renderer是为双核浏览器准备的，用于指定双核浏览器默认以何种方式渲染页面。比如说360浏览器。举例： 123&lt;meta name=\"renderer\" content=\"webkit\"&gt; //默认webkit内核&lt;meta name=\"renderer\" content=\"ie-comp\"&gt; //默认IE兼容模式&lt;meta name=\"renderer\" content=\"ie-stand\"&gt; //默认IE标准模式 国内双核浏览器默认内核模式如下： 搜狗高速浏览器、QQ浏览器：IE内核（兼容模式） 360极速浏览器、遨游浏览器：Webkit内核（极速模式） 1&lt;meta name=\"renderer\" content=\"webkit | ie-comp | ie-stand\"&gt; I . viewport(移动端的窗口) 能优化移动浏览器的显示。如果不是响应式网站，不要使用initial-scale或者禁用缩放。大部分4.7-5寸设备的viewport宽设为360px；5.5寸设备设为400px；iphone6设为375px；ipone6 plus设为414px。 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no\"/&gt; width=device-width 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 。 width：宽度（数值 / device-width）（范围从200 到10,000，默认为980 像素） height：高度（数值 / device-height）（范围从223 到10,000） initial-scale：初始的缩放比例 （范围从&gt;0 到10） minimum-scale：允许用户缩放到的最小比例 maximum-scale：允许用户缩放到的最大比例 user-scalable：用户是否可以手动缩 (no,yes) minimal-ui：可以在页面加载时最小化上下状态栏。（已弃用）注意，很多人使用initial-scale=1到非响应式网站上，这会让网站以100%宽度渲染，用户需要手动移动页面或者缩放。如果和initial-scale=1同时使用user-scalable=no或maximum-scale=1，则用户将不能放大/缩小网页来看到全部的内容。使用（&lt;meta name=“viewport” content=“width=device-width,user-scalable=yes”&gt;） 其他的用法 123456789101112131415161718 &lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;&lt;meta name=\"HandheldFriendly\" content=\"true\"&gt;&lt;!-- 微软的老式浏览器 --&gt;&lt;meta name=\"MobileOptimized\" content=\"320\"&gt;&lt;!-- uc强制竖屏 --&gt;&lt;meta name=\"screen-orientation\" content=\"portrait\"&gt;&lt;!-- QQ强制竖屏 --&gt;&lt;meta name=\"x5-orientation\" content=\"portrait\"&gt;&lt;!-- UC强制全屏 --&gt;&lt;meta name=\"full-screen\" content=\"yes\"&gt;&lt;!-- QQ强制全屏 --&gt;&lt;meta name=\"x5-fullscreen\" content=\"true\"&gt;&lt;!-- UC应用模式 --&gt;&lt;meta name=\"browsermode\" content=\"application\"&gt;&lt;!-- QQ应用模式 --&gt;&lt;meta name=\"x5-page-mode\" content=\"app\"&gt;&lt;!-- windows phone 点击无高光 --&gt;&lt;meta name=\"msapplication-tap-highlight\" content=\"no\"&gt; 1234567891011121314151617&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\" /&gt;&lt;!-- 启用 WebApp 伪装app，离线应用。) 全屏模式 --&gt;&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black-translucent\" /&gt;&lt;!-- 隐藏状态栏/设置状态栏颜色：只有在开启WebApp全屏模式时才生效。content的值为default | black | black-translucent --&gt;&lt;meta name=\"apple-mobile-web-app-title\" content=\"标题\"&gt;&lt;!-- 添加到主屏后的标题 --&gt;&lt;meta content=\"telephone=no\" name=\"format-detection\" /&gt; &lt;!-- 忽略数字自动识别为电话号码 --&gt;&lt;meta content=\"email=no\" name=\"format-detection\" /&gt;&lt;!-- 忽略识别邮箱 --&gt;&lt;meta name=\"apple-itunes-app\" content=\"app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL\"&gt; &lt;!-- 添加智能 App 广告条 Smart App Banner：告诉浏览器这个网站对应的app，并在页面上显示下载banner --&gt; 2. http-equiv属性 http-equiv顾名思义，相当于http的文件头作用。相当于HTTP的作用，比如说定义些HTTP参数啥的。 1&lt;meta http-equiv=&quot;参数&quot; content=&quot;具体的描述&quot;&gt; 其中http-equiv属性主要有以下几种参数： A. content-Type(设定网页字符集)(推荐使用HTML5的方式) 说明：用于设定网页字符集，便于浏览器解析与渲染页面举例： 12345&lt;meta http-equiv=\"content-Type\" content=\"text/html;charset=utf-8\"&gt; //旧的HTML，不推荐 &lt;meta charset=\"utf-8\"&gt; //HTML5设定网页字符集的方式，推荐使用UTF-8 B. X-UA-Compatible(浏览器采取何种版本渲染当前页面) 说明：用于告知浏览器以何种版本来渲染页面。（一般都设置为最新模式，在各大框架中这个设置也很常见。 举例： 1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"/&gt; //指定IE和Chrome使用最新版本渲染当前页面 优先使用 IE 最新版本和 Chrome 12345 &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" /&gt;&lt;!-- 关于X-UA-Compatible --&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=6\" &gt;&lt;!-- 使用IE6 --&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=7\" &gt;&lt;!-- 使用IE7 --&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=8\" &gt;&lt;!-- 使用IE8 --&gt; C. cache-control(指定请求和响应遵循的缓存机制) 举例: 1&lt;meta http-equiv=\"cache-control\" content=\"no-cache\"&gt; 共有以下几种用法： no-cache: 先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存。 no-store: 不允许缓存，每次都要去服务器上，下载完整的响应。（安全措施） public : 缓存所有响应，但并非必须。因为max-age也可以做到相同效果 private : 只为单个用户缓存，因此不允许任何中继进行缓存。（比如说CDN就不允许缓存private的响应） maxage : 表示当前请求开始，该响应在多久内能被缓存和重用，而不去服务器重新请求。例如：max-age=60表示响应可以再缓存和重用 60 秒。 D. expires(网页到期时间) 说明:用于设定网页的到期时间，过期后网页必须到服务器上重新传输。举例： 1&lt;meta http-equiv=\"expires\" content=\"Sunday 26 October 2016 01:00 GMT\" /&gt; E. refresh(自动刷新并指向某页面) 说明：网页将在设定的时间内，自动刷新并调向设定的网址。举例: 12&lt;meta http-equiv=\"refresh\" content=\"2；URL=http://www.lxxyx.win/\"&gt;//意思是2秒后跳转向我的博客 F. Set-Cookie(cookie设定) 说明：如果网页过期。那么这个网页存在本地的cookies也会被自动删除。 123&lt;meta http-equiv=\"Set-Cookie\" content=\"name, date\"&gt; //格式&lt;meta http-equiv=\"Set-Cookie\" content=\"User=Lxxyx; path=/; expires=Sunday, 10-Jan-16 10:00:00 GMT\"&gt; //具体范例 G. Content-Language （设置网页语言） 1&lt;meta http-equiv=\"content-Language\" contect=\"zh-CN\"&gt; 3. 移动端的meta format-detection 对电话号码的识别 1&lt;meta name=\"format-detection\" content=\"telephone=no\" /&gt; IOS私有属性 apple-mobile-web-app-capable 是否启动webapp功能，会删除默认的苹果工具栏和菜单栏。 1&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\" /&gt; apple-mobile-web-app-status-bar-style 当启动webapp功能时，显示手机信号、时间、电池的顶部导航栏的颜色。默认值为default（白色），可以定为black（黑色）和black-translucent（灰色半透明）。这个主要是根据实际的页面设计的主体色为搭配来进行设置。 1&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" /&gt; 示例： 12345678910111213141516171819202122232425262728293031&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, user-scalable=no\" /&gt;&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\" /&gt;&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" /&gt;&lt;meta name=\"format-detection\"content=\"telephone=no, email=no\" /&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, user-scalable=no\" /&gt;&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\" /&gt;&lt;!-- 删除苹果默认的工具栏和菜单栏 --&gt;&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" /&gt;&lt;!-- 设置苹果工具栏颜色 --&gt;&lt;meta name=\"format-detection\" content=\"telphone=no, email=no\" /&gt;&lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt;&lt;!-- 启用360浏览器的极速模式(webkit) --&gt;&lt;meta name=\"renderer\" content=\"webkit\"&gt;&lt;!-- 避免IE使用兼容模式 --&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;&lt;meta name=\"HandheldFriendly\" content=\"true\"&gt;&lt;!-- 微软的老式浏览器 --&gt;&lt;meta name=\"MobileOptimized\" content=\"320\"&gt;&lt;!-- uc强制竖屏 --&gt;&lt;meta name=\"screen-orientation\" content=\"portrait\"&gt;&lt;!-- QQ强制竖屏 --&gt;&lt;meta name=\"x5-orientation\" content=\"portrait\"&gt;&lt;!-- UC强制全屏 --&gt;&lt;meta name=\"full-screen\" content=\"yes\"&gt;&lt;!-- QQ强制全屏 --&gt;&lt;meta name=\"x5-fullscreen\" content=\"true\"&gt;&lt;!-- UC应用模式 --&gt;&lt;meta name=\"browsermode\" content=\"application\"&gt;&lt;!-- QQ应用模式 --&gt;&lt;meta name=\"x5-page-mode\" content=\"app\"&gt;&lt;!-- windows phone 点击无高光 --&gt;&lt;meta name=\"msapplication-tap-highlight\" content=\"no\"&gt;&lt;!-- 适应移动端end --&gt;","categories":[{"name":"HTML-CSS","slug":"HTML-CSS","permalink":"https://wkd709.github.io/categories/HTML-CSS/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://wkd709.github.io/tags/HTML/"}]},{"title":"浏览器的渲染：过程与原理","slug":"浏览器的渲染：过程与原理","date":"2018-08-23T16:00:00.000Z","updated":"2018-08-24T02:43:51.259Z","comments":true,"path":"2018/08/24/浏览器的渲染：过程与原理/","link":"","permalink":"https://wkd709.github.io/2018/08/24/浏览器的渲染：过程与原理/","excerpt":"","text":"1、大致的整个过程 1、用户输入url地址 2、浏览器解析url，解析出主机名 3、浏览器将主机名转换成服务器ip地址（浏览器先查询本地DNS缓存列表 没有的话 再向浏览器默认的DNS服务器发送查询请求 同时缓存） 4、浏览器将端口号从url中解析出来 5、浏览器建立一条与目标Web服务器的TCP连接（三次握手） 6、浏览器向服务器发送一条HTTP请求报文 7、服务器向浏览器返回一条HTTP响应报文 8、关闭连接 浏览器解析文档2.浏览器渲染页面的过程 从耗时的角度，浏览器请求、加载、渲染一个页面，时间在下面五件事上： 1.DNS查询2.TCP连接3.HTTP请求即响应4.服务端响应5.客户端渲染 1.DNS查询 DNS解析是一个递归查询的过程。 上述图片是查找www.google.com 的IP地址过程。首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。从上述过程中，可以看出网址的解析是一个从右向左的过程: com -&gt; google.com -&gt; www.google.com。 但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是www.google.com.， 并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为: . -&gt; .com -&gt; google.com. -&gt; www.google.com.。 DNS优化 了解了DNS的过程，可以为我们带来哪些？上文中请求到google的IP地址时，经历了8个步骤，这个过程中存在多个请求(同时存在UDP和TCP请求，为什么有两种请求方式，请自行查找)。如果每次都经过这么多步骤，是否太耗时间？如何减少该过程的步骤呢？那就是DNS缓存。 DNS缓存 DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。 2.TCP连接 TCP/IP不是一个协议，而是一个协议族的统称。里面包括了IP协议，IMCP协议，TCP协议，以及我们更加熟悉的http、ftp、pop3协议等等。 TCP/IP协议分层 主要是TCP三次握手：所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发，整个流程如下图所示： （1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。 （2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。 （3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。 简单来说，就是 1、建立连接时，客户端发送SYN包（SYN=i）到服务器，并进入到SYN-SEND状态，等待服务器确认 2、服务器收到SYN包，必须确认客户的SYN（ack=i+1）,同时自己也发送一个SYN包（SYN=k）,即SYN+ACK包，此时服务器进入SYN-RECV状态 3、客户端收到服务器的SYN+ACK包，向服务器发送确认报ACK（ack=k+1）,此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手，客户端与服务器开始传送数据。 3.HTTP请求即响应HTTP Request 这里不多介绍 4.服务端响应Response 这里不多介绍 5.客户端渲染 浏览器在收到HTML,CSS,JS文件后，它是如何把页面呈现到屏幕上的？下图对应的就是WebKit渲染的过程。分为五个步骤： 1.处理html标记并构建DOM树。 解析html过程中，会碰到几类特殊的节点需要特殊的处理： 1). style、link元素以及具有内联样式的元素：交给CSSOM生成 2). script（无论是否外链）元素：见’script标签的处理’ 2.处理css标记并构建成CSSOM树。 style和内联样式 对于这两类，浏览器会直接根据样式声明生成CSSOM，因为他们本身就直接包含了样式内容。 link 对于外联样，浏览器会先发送请求，待请求成功后获取外联样式，浏览器会解析该外联样式，并生成相应的CSSOM。 由于CSSOM负责存储渲染信息，浏览器就必须保证在合成渲染树之前，CSSOM是完备的，这种完备是指所有的CSS（内联、内部和外部）都已经下载完，并解析完，只有CSSOM和DOM的解析完全结束，浏览器才会进入下一步的渲染，这就是传说中的CSS阻塞渲染。 CSS阻塞渲染意味着，在CSSOM完备前，页面将一直处理白屏的状态，这就是为何样要放在head中，仅仅是为了更快地的解析CSS，保证更快的首次渲染。 需要注意的是，即便你没有给页面任何的样式声明，CSSOM依然会生成，默认生成的CSSOM自带浏览器默认样式。 样式解析生成的CSSOM便含有渲染信息，这些信息会与DOM一起，生成渲染树Render-Tree。最后，一样附上Chrome官方的事例来个总结： 12345body &#123; font-size: 16px &#125;p &#123; font-weight: bold &#125;span &#123; color: red &#125;p span &#123; display: none &#125;img &#123; float: right &#125; 在讲渲染树前，我们还需要讲讲一直被我们搁置的script。 script标签的处理 Js可以操作DOM来修改DOM结构，可以操作CSSOM来修改节点样式，这就导致了浏览器在解析HMTL时，一旦碰到script，就会立即停止HTML的解析（而css不会），执行js，再返还控制权。 事实上，JS执行前不仅仅是停止了HTML的解析，它还必须等待CSS的解析完成。当浏览器碰到script元素时，发现该元素前面的CSS还未解析完，就会等待CSS解析完成，再去执行JS。 JS阻塞了HTML的解析，也阻塞了其后的CSS解析，整个解析进程必须等待JS的执行完成才能够继续，这就是所谓的JS阻塞页面。一个script标签，推迟了DOM的生成、CSSOM的生成以及之后的所有渲染过程，从性能角度上讲，将script放在页面底部，也就合情合理了。 3.将DOM与CSSOM合并成一个渲染树。 当DOM和CSSOM构建完成，它们一个存储了节点信息，一个存储了节点渲染信息，都不能直接用来渲染，为此浏览器会将两者结合，生成渲染树（Render-Tree），这棵树就包含了页面所有可见元素及其渲染信息。仍以上述同样的例子： 生成渲染树，浏览器做了这些工作： 从DOM的根节点开始，遍历每个可视节点：script、link、meta都属于不可视节点，另外，display: none的节点也属于不可视节点 从CSSOM中搜索可视节点的样式 计算这些样式，将计算值应用到可视节点上 4.根据渲染树来布局，以计算每个节点的几何信息。 渲染树生成后，还是没有办法渲染到屏幕上，渲染到屏幕需要得到各个节点的位置信息，这就需要布局（Layout）的处理了。 布局 渲染树生成后，浏览器便可以根据渲染树中的样式信息，结合设备的屏幕信息，计算每个元素的位置和尺寸。 5.将各个节点绘制到屏幕上。 得到了渲染树及其节点的布局信息，浏览器便可以将最终的页面渲染到屏幕。 整个关键渲染路径主要就包括了以上这些步骤，每个步骤的快慢都决定着页面的性能，或者说网站的性能，因此，谈到首屏或者首渲的性能优化，就不得不从关键渲染路径着手，每一步都是有或多或少的可优化点。一些优化建议什么的，就不在本文范围了。 当我们的页面首渲完成后，会有很多页面交互，例如：动画、用户点击、滚屏。所有的交互都会引发浏览器新的渲染操作，这些操作直接影响着用户交互性能，Chrome官网里直接称作渲染性能","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://wkd709.github.io/categories/浏览器/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://wkd709.github.io/tags/浏览器/"}]},{"title":"flex布局","slug":"flex布局","date":"2018-08-23T16:00:00.000Z","updated":"2018-08-24T02:20:47.578Z","comments":true,"path":"2018/08/24/flex布局/","link":"","permalink":"https://wkd709.github.io/2018/08/24/flex布局/","excerpt":"","text":"[TOC] 网页布局（layout）是css的一个重点应用。 布局的传统解决方案，基于盒状模型，依赖==display==属性 + ==float==属性。它对于那些特殊布局非常不便，比如，==垂直居中==就不容易实现。 各大浏览器的兼容性如下: 一、Flex布局是什么？ Flex是Flexible Box 的缩写，意为’弹性布局’，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。 123.box &#123; display: block;&#125; 行内元素也可以使用Flex布局。 123.box &#123; display: inline-flex;&#125; webkit内核的浏览器，必须加上 ==-webkit-== 前缀。 1234.box &#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意：，设为Flex布局以后，子元素的 ==float==、==clear==和==vertical-aligin==属性将失效。 二、基本概念 采用Flex布局的元素，称为Flex容器（flex container),简称“容器”。它的所有子元素自动称为容器成员，称为Flex项目（flex item),简称“项目”。 容器默认存在两根轴：水平的主轴（main axis)。主轴的开始位置（与边框的交叉点）叫做==main start==，结束位置叫做 ==main end==;交叉轴的开始位置叫做==cross start==，结束位置叫做==cross end==。 项目默认沿主轴排列。单个项目占据的主轴空间叫做==main size==,占据的交叉轴空间叫做==cross size==。 三、容器的属性 以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content 3.1 flex-direction flex-direction 属性决定主轴的方向（即项目的排列方向）。 123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 四种： 它可能有4个值。 row (默认值)： 主轴为水平方向，起点在左端。 row-reverse： 主轴为水平方向，起点在右端。 column： 主轴为垂直方向，起点在上沿。 column-reverse： 主轴为垂直方向，起点在下沿。 3.2 flex-wrap属性 默认情况下，项目都排在一条线（又称‘轴线’）上。==flex-wrap==属性定义，如果一条轴线排不下，如何换行。 123.box &#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值。（1）、==nowrap==（默认）： 不换行 （2）、==wrap==：换行，第一行在上方。 （3）、==wrap-reverse==：换行，第一行在下方。 3.3 flex-flow 123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; 3.4 justify-content属性 ==justify-content==属性定义了项目在主轴上的对齐方式。123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 以下： 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start (默认值) : 左对齐 flex-end : 右对齐 center ： 居中 space-between : 两端对齐，项目之前的间隔都相等。 space-around : 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 3.5 align-items属性 ==alig-items==属性定义项目在交叉轴上如何对齐。123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 以下： 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline：项目的第一行文字的基线对齐。 stretch （默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content 属性 ==align-content==属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。123.box &#123; align-content : flex-start | flex-end | center | space-between | space-around&#125; 以下： 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch （默认值）：轴线占满整个交叉轴。 四、项目的属性 以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 4.1 order属性 ==order==属性定义项目的排列顺序。数值越小，排列越靠前，默认为0； 123.item &#123; order: &lt;integer&gt;;&#125; 以下: 4.2 flex-grow属性 ==flex-grow==属性定义项目的放大比例，默认为==0==，即如果存在剩余空间，也不放大。 123.item &#123; flex-grow: &lt;number&gt;; /* default 0*/&#125; 以下： 如果所有项目的==flex-grow==属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的==flex-grow==属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性 ==flex-shrink==属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1*/;&#125; 以下： 如果所有项目的==flex-shrink==属性都为1，当空间不足时，都将等比缩小。如果一个项目的==flex-shrink==属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 4.4 flex-basis属性 ==flex-basis==属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否多余空间。它的默认值为==auto==,即项目的本来大小。 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟==width==或==height==属性一样的值（比如350px）,则项目占据固定空间。 4.5 flex属性 ==flex==属性是==flex-grow==,==flex-shrink==和==flex-basis==的简写，默认值为==0 1 auto==。后两个属性可选。 123.item &#123;flex: none | [&lt;&apos;flex-grow&apos;&gt;&lt;&apos;flex-shrink&apos;&gt; ? || &lt;&apos;flex-basis&apos;&gt; ] &#125; 属性有两个快捷值： ==auto== (==1 1 auto==) 和 none (==0 0 auto==)。建议优选使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self 属性 ==align-self==属性允许单个项目有与其他项目不一样的对齐方式，可覆盖==align-item==属性。默认值为==auto==,表示继承符=父元素的==align-items==属性，如果没有父元素，则等同于==stretch==。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | strectch ;&#125; 以下： 该属性可能取6个值，除了auto,其他都与align-items属性完全一致。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://wkd709.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://wkd709.github.io/tags/CSS/"}]},{"title":"深拷贝与浅拷贝","slug":"深拷贝与浅拷贝","date":"2018-08-23T16:00:00.000Z","updated":"2018-08-24T02:35:37.907Z","comments":true,"path":"2018/08/24/深拷贝与浅拷贝/","link":"","permalink":"https://wkd709.github.io/2018/08/24/深拷贝与浅拷贝/","excerpt":"","text":"堆和栈的区别其实深拷贝和浅拷贝的主要区别就是其在内存中的存储类型不同。 堆和栈都是内存中划分出来用来存储的区域。 栈（stack）为自动分配的内存空间，它由系统自动释放；而堆（heap）则是动态分配的内存，大小不定也不会自动释放。 基本数据类型基本数据类型主要是：undefined，boolean，number，string，null。 基本数据类型存放在栈中 存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配，是直接按值存放的，所以可以直接访问。 基本数据类型值不可变 基本数据类型的值是不可变的，动态修改了基本数据类型的值，它的原始值也是不会改变的，例如 12345var str = &quot;abc&quot;;console.log(str[1]=&quot;f&quot;); // fconsole.log(str); // abc 基本类型的比较是值的比较 基本类型的比较是值的比较，只要它们的值相等就认为他们是相等的，例如： 123var a = 1; var b = 1; console.log(a === b);//true 比较的时候最好使用严格等，因为 == 是会进行类型转换的，比如： 123var a = 1; var b = true; console.log(a == b);//true 引用类型引用类型存放在堆中 引用类型（object）是存放在堆内存中的，变量实际上是一个存放在栈内存的指针，这个指针指向堆内存中的地址。每个空间大小不一样，要根据情况开进行特定的分配，例如。 123var person1 = &#123;name:&apos;jozo&apos;&#125;;var person2 = &#123;name:&apos;xiaom&apos;&#125;;var person3 = &#123;name:&apos;xiaoq&apos;&#125;; 引用类型值可变 引用类型是可以直接改变其值的，例如： 123var a = [1,2,3];a[1] = 5;console.log(a[1]); // 5 引用类型的比较是引用的比较 所以每次我们对 js 中的引用类型进行操作的时候，都是操作其对象的引用（保存在栈内存中的指针），所以比较两个引用类型，是看其的引用是否指向同一个对象。例如： 123var a = [1,2,3];var b = [1,2,3];console.log(a === b); // false 虽然变量 a 和变量 b 都是表示一个内容为 1，2，3 的数组，但是其在内存中的位置不一样，也就是说变量 a 和变量 b 指向的不是同一个对象，所以他们是不相等的。 传值与传址了解了基本数据类型与引用类型的区别之后，我们就应该能明白传值与传址的区别了。在我们进行赋值操作的时候，基本数据类型的赋值（=）是在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中。例如： 123456var a = 10;var b = a;a ++ ;console.log(a); // 11console.log(b); // 10 所以说，基本类型的赋值的两个变量是两个独立相互不影响的变量。 是引用类型的赋值是传址。只是改变指针的指向，例如，也就是说引用类型的赋值是对象保存在栈中的地址的赋值，这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响。例如： 123456789101112var a = &#123;&#125;; // a保存了一个空对象的实例var b = a; // a和b都指向了这个空对象a.name = &apos;jozo&apos;;console.log(a.name); // &apos;jozo&apos;console.log(b.name); // &apos;jozo&apos;b.age = 22;console.log(b.age);// 22console.log(a.age);// 22console.log(a == b);// true 浅拷贝赋值（=）和浅拷贝的区别 深拷贝：将 B 对象拷贝到 A 对象中，包括 B 里面的子对象， 浅拷贝：将 B 对象拷贝到 A 对象中，但不包括 B 里面的子对象 深拷贝深拷贝是对对象以及对象的所有子对象进行拷贝。 方法（浅拷贝）1. Object.assign()es5源码：1234567891011121314151617181920212223 if (typeof Object.assign != &apos;function&apos;) &#123; (function () &#123; Object.assign = function (target) &#123; &apos;use strict&apos;; if (target === undefined || target === null) &#123; throw new TypeError(&apos;Cannot convert undefined or null to object&apos;); &#125; var output = Object(target); for (var index = 1; index &lt; arguments.length; index++) &#123; var source = arguments[index]; if (source !== undefined &amp;&amp; source !== null) &#123; for (var nextKey in source) &#123; if (source.hasOwnProperty(nextKey)) &#123; output[nextKey] = source[nextKey]; &#125; &#125; &#125; &#125; return output; &#125;;&#125;)();&#125; Object.assign方法用于对象的合并，将源对象（ source ）的所有可枚举属性，复制到目标对象（ target ）。12345var target = &#123; a: 1 &#125;;var source1 = &#123; b: 2 &#125;;var source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。 注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 12345var target = &#123; a: 1, b: 1 &#125;;var source1 = &#123; b: 2, c: 2 &#125;;var source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 如果只有一个参数，Object.assign会直接返回该参数。12var obj = &#123;a: 1&#125;;Object.assign(obj) === obj // true 如果该参数不是对象，则会先转成对象，然后返回。1typeof Object.assign(2) // &quot;object&quot; 由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。12Object.assign(undefined) // 报错Object.assign(null) // 报错 如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错。 123let obj = &#123;a: 1&#125;;Object.assign(obj, undefined) === obj // trueObject.assign(obj, null) === obj // true 其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。 12345var v1 = &apos;abc&apos;;var v2 = true;var v3 = 10;var obj = Object.assign(&#123;&#125;, v1, v2, v3);console.log(obj); // &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125; 注意点： Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。Object.assign()与解构一样，只能深拷贝一级的对象。 1234var obj1 = &#123;a: &#123;b: 1&#125;&#125;;var obj2 = Object.assign(&#123;&#125;, obj1);obj1.a.b = 2;obj2.a.b // 2 对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。 1234var target = &#123; a: &#123; b: &apos;c&apos;, d: &apos;e&apos; &#125; &#125;var source = &#123; a: &#123; b: &apos;hello&apos; &#125; &#125;Object.assign(target, source)// &#123; a: &#123; b: &apos;hello&apos; &#125; &#125; 2. 自定义浅拷贝方法12345678910111213// 浅拷贝实现，仅供参考function shallowClone(source) &#123; if (!source || typeof source !== &apos;object&apos;) &#123; throw new Error(&apos;error arguments&apos;); &#125; var targetObj = source.constructor === Array ? [] : &#123;&#125;; for (var keys in source) &#123; if (source.hasOwnProperty(keys)) &#123; targetObj[keys] = source[keys]; &#125; &#125; return targetObj;&#125; 方法 （深拷贝）：1. JSON字符串使用JSON字符串进行深拷贝，多层嵌套对象也可以进行深拷贝123456var a = &#123;a:&apos;123&apos;,b:&#123;c:&apos;333&apos;&#125;&#125;var b = JSON.parse(JSON.stringify(a));b.a = &apos;yyy&apos;b.b.c =222;console.log(a.a); // 123console.log(a.b.c); // 333 可以封装如下函数 123456789101112131415var cloneObj = function(obj)&#123; var str, newobj = obj.constructor === Array ? [] : &#123;&#125;; if(typeof obj !== &apos;object&apos;)&#123; return; &#125; else if(window.JSON)&#123; str = JSON.stringify(obj), //系列化对象 newobj = JSON.parse(str); //还原 &#125; else &#123; for(var i in obj)&#123; newobj[i] = typeof obj[i] === &apos;object&apos; ? cloneObj(obj[i]) : obj[i]; &#125; &#125; return newobj;&#125;; 2. jQuery.extend()方法源码实现源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960jQuery.extend = jQuery.fn.extend = function() &#123; //给jQuery对象和jQuery原型对象都添加了extend扩展方法 var options, name, src, copy, copyIsArray, clone, target = arguments[0] || &#123;&#125;, i = 1, length = arguments.length, deep = false; //以上其中的变量：options是一个缓存变量，用来缓存arguments[i]，name是用来接收将要被扩展对象的key，src改变之前target对象上每个key对应的value。 //copy传入对象上每个key对应的value，copyIsArray判定copy是否为一个数组，clone深拷贝中用来临时存对象或数组的src。 // 处理深拷贝的情况 if (typeof target === &quot;boolean&quot;) &#123; deep = target; target = arguments[1] || &#123;&#125;; //跳过布尔值和目标 i++; &#125; // 控制当target不是object或者function的情况 if (typeof target !== &quot;object&quot; &amp;&amp; !jQuery.isFunction(target)) &#123; target = &#123;&#125;; &#125; // 当参数列表长度等于i的时候，扩展jQuery对象自身。 if (length === i) &#123; target = this; --i; &#125; for (; i &lt; length; i++) &#123; if ((options = arguments[i]) != null) &#123; // 扩展基础对象 for (name in options) &#123; src = target[name]; copy = options[name]; // 防止永无止境的循环，这里举个例子， // 如 var a = &#123;name : b&#125;; // var b = &#123;name : a&#125; // var c = $.extend(a, b); // console.log(c); // 如果没有这个判断变成可以无限展开的对象 // 加上这句判断结果是 &#123;name: undefined&#125; if (target === copy) &#123; continue; &#125; if (deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) &#123; if (copyIsArray) &#123; copyIsArray = false; clone = src &amp;&amp; jQuery.isArray(src) ? src: []; // 如果src存在且是数组的话就让clone副本等于src否则等于空数组。 &#125; else &#123; clone = src &amp;&amp; jQuery.isPlainObject(src) ? src: &#123;&#125;; // 如果src存在且是对象的话就让clone副本等于src否则等于空数组。 &#125; // 递归拷贝 target[name] = jQuery.extend(deep, clone, copy); &#125; else if (copy !== undefined) &#123; target[name] = copy; // 若原对象存在name属性，则直接覆盖掉；若不存在，则创建新的属性。 &#125; &#125; &#125; &#125; // 返回修改的对象 return target;&#125;; jQuery的extend方法使用基本的递归思路实现了浅拷贝和深拷贝，但是这个方法也无法处理源对象内部循环引用，例如： 12345var a = &#123;&quot;name&quot;:&quot;aaa&quot;&#125;;var b = &#123;&quot;name&quot;:&quot;bbb&quot;&#125;;a.child = b;b.parent = a;$.extend(true,&#123;&#125;,a);//直接报了栈溢出。Uncaught RangeError: Maximum call stack size exceeded 3. 自定义深拷贝方法1234567891011121314151617181920212223242526272829303132// 递归实现一个深拷贝function deepClone(source)&#123; if(!source || typeof source !== &apos;object&apos;)&#123; throw new Error(&apos;error arguments&apos;, &apos;shallowClone&apos;); &#125; var targetObj = source.constructor === Array ? [] : &#123;&#125;; for(var keys in source)&#123; if(source.hasOwnProperty(keys))&#123; if(source[keys] &amp;&amp; typeof source[keys] === &apos;object&apos;)&#123; targetObj[keys] = source[keys].constructor === Array ? [] : &#123;&#125;; targetObj[keys] = deepClone(source[keys]); &#125;else&#123; targetObj[keys] = source[keys]; &#125; &#125; &#125; return targetObj;&#125;// test examplevar o1 = &#123; arr: [1, 2, 3], obj: &#123; key: &apos;value&apos; &#125;, func: function()&#123; return 1; &#125;&#125;;var o3 = deepClone(o1);console.log(o3 === o1); // =&gt; falseconsole.log(o3.obj === o1.obj); // =&gt; falseconsole.log(o2.func === o1.func); // =&gt; true","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wkd709.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wkd709.github.io/tags/JavaScript/"}]},{"title":"http协议","slug":"http协议","date":"2018-08-23T16:00:00.000Z","updated":"2018-08-24T02:45:17.688Z","comments":true,"path":"2018/08/24/http协议/","link":"","permalink":"https://wkd709.github.io/2018/08/24/http协议/","excerpt":"","text":"http构建与TCP/IP协议之上，默认端口号是80 htpp是无连接无状态的 http协议的主要特点： 支持客户/服务器模式 简单快速： 客户向服务器请求服务时，只需要传送请求方式和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型有==Content-type==加以标记。 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议。无状态是指协议对事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大 。另一方面，在服务器不需要先前信息时它的应答就比较快。一、HTTP报文 1.请求报文http协议是以 ASCII 码传输，建立在TCP/IP协议之上的应用规范。规范把http请求份为三个部分：状态行、请求头、消息主体。类似于下面这样： 1234&lt;method&gt;&lt;request-URL&gt;&lt;version&gt;&lt;headers&gt;&lt;entity-body&gt; http定义了与服务器交互的不同方法，基本的方法有4种，分别是==GET==，==POST==，==PUT==,==DELETE==。==URL==全称是资源描述符，我们可以这样认为：一个==URL==地址，它用于描述一个网络上的资源，而http中 的==GET==，==POST==，==PUT==,==DELETE==就对应着这个资源的查，增，改，删4个操作。 GET用于信息获取，而且应该是安全的 和 幂等的。 所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。 幂等的意味着对同一URL的多个请求应该返回同样的结果。 GET请求报文示例： 12345 GET /books/?sex=man&amp;name=Professional HTTP/1.1 Host: www.example.com User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6) Gecko/20050225 Firefox/1.0.1Connection: Keep-Alive http条件get使用的时机？ 客户之前已经访问过某网站，并打算再次访问该网站。 http条件get使用的方法？ 客户端向服务器发送一个包询问是否在上一次访问网站的时间后是否更改了页面，如果服务器没有更新，显然不需要把整个网页传给客户端，客户端只要使用本地缓存即可，如果服务器对照客户端给出的时间已经更新了客户端请求的网页，则发送这个更新了的网页给用户。 下面是一个具体的发送接受报文示例： 客户端发送请求： 1234 GET / HTTP/1.1 Host: www.sina.com.cn:80 If-Modified-Since:Thu, 4 Feb 2010 20:39:13 GMT Connection: Close 第一次请求时，服务器端返回请求数据，之后的请求，服务器根据请求中的 If-Modified-Since 字段判断响应文件没有更新，如果没有更新，服务器返回一个 304 Not Modified响应，告诉浏览器请求的资源在浏览器上没有更新，可以使用已缓存的上次获取的文件。 12345678 HTTP/1.0 304 Not Modified Date: Thu, 04 Feb 2010 12:38:41 GMT Content-Type: text/html Expires: Thu, 04 Feb 2010 12:39:41 GMT Last-Modified: Thu, 04 Feb 2010 12:29:04 GMT Age: 28 X-Cache: HIT from sy32-21.sina.com.cn Connection: close 如果服务器端资源已经更新的话，就返回正常的响应。 POST表示可能修改变服务器上的资源的请求。 123456789 POST / HTTP/1.1Host: www.example.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 40Connection: Keep-Alivesex=man&amp;name=Professional 注意： （1）、GET 可提交的数据量受到URL长度的限制，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制（2）、理论上讲，POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制，出于安全考虑，服务器软件在实现时会做一定限制（3）、参考上面的报文示例，可以发现 GET 和 POST 数据内容是一模一样的，只是位置不同，一个在URL里，一个在 HTTP 包的包体里 2、POST提交数据的方式HTTP 协议中规定 POST 提交的数据必须在 body 部分中，但是协议中没有规定数据使用哪种编码方式或者数据格式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。 但是，数据发送出去，还要服务端解析成功才有意义。一般服务端语言如 php、python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。 所以说到 POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分。 下面就正式开始介绍它们： 1application/x-www-form-urlencoded 这是最常见的 ==POST 数据提交==方式。浏览器的原生form表单，如果不设置 enctype 属性，那么最终就会以 ==application/x-www-form-urlencoded== 方式提交数据。上个小节当中的例子便是使用了这种提交方式。 可以看到 body 当中的内容和 GET 请求是完全相同的。 1multipart/form-data 这又是一个常见的 POST 数据提交的方式。我们使用表单==上传文件==时，必须让 form表单的 enctype 等于 ==multipart/form-data==。直接来看一个请求示例： 12345678910111213 POST http://www.example.com HTTP/1.1Content-Type:multipart/form-data; boundary=---- WebKitFormBoundaryrGKCBY7qhFd3TrwA------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;text&quot;title------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;Content-Type: image/pngPNG ... content of chrome.png ...------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 form 表单也只支持这两种方式（通过 form元素的 enctype 属性指定，默认为 application/x-www-form-urlencoded。其实 enctype 还支持 text/plain，不过用得非常少）。 随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，例如 ==application/json==，==text/xml==，乃至 ==application/x-protobuf== 这种二进制格式，只要服务器可以根据 Content-Type 和 Content-Encoding 正确地解析出请求，都是没有问题的。 3. 响应报文http响应与http请求类似，http响应也由三个部分构成，分别是： 状态行 响应头（Response Header） 响应正文 状态行由协议版本、数字形式的状态代码、以及响应的状态描述，各元素之间以空格分隔。 常见的状态码如下： 200 OK 客户端请求成功 301 Moved Permanently 请求永久重定向 302 Moved Temporarily 请求临时重定向 304 Not Modified 文件未修改，可以直接使用缓存的文件。 400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。 401 Unauthorized 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因 404 Not Found 请求的资源不存在，例如，输入了错误的URL 500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。 503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。 二、消息报头 HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行），消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成。 http消息爆头包括： 请求报头 响应报头 实体报头每一个报头域都是由名字+“： ”+ 空格+ 值 组成，消息报头域的名字是大小写无关的。 1. 普通报头在普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。 ==Cache-Control==eg：Cache-Control 用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），http1.0使用的类似的报头域为Pragma。请求的缓存指令包括：no-cache(用于指示请求或响应消息不能缓存)、no-store、max-age、max-stale、min-fresh、only-if-cached; 响应时的缓存指令包括：public、private、no-cache、no-store、no-trnsform、must-revalidate、proxy-revalidate、max-age、s-maxage。eg:为了指示IE浏览器（客户端）不要缓存页面，服务端的jsp程序可以编写如下：response.setHeader（’Cache-Control’,’no-cache’）;//response.setHeader（pragma’,’no-cache’）;作用相当于上述代码，通常两者 //合用 这句代码将在发送的响应消息中设置普通报头域：Cache-Control:no-cache ==Date== 普通报头域表示消息产生的日期和时间 ==Connection== 普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接。 我们知道 HTTP 协议采用“请求-应答”模式，当使用普通模式，即非 Keep-Alive 模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）；当使用 Keep-Alive 模式（又称持久连接、连接重用）时，Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接。在 HTTP 1.0 版本中，并没有官方的标准来规定 Keep-Alive 如何工作，因此实际上它是被附加到 HTTP 1.0协议上，如果客户端浏览器支持 Keep-Alive ，那么就在HTTP请求头中添加一个字段 Connection: Keep-Alive，当服务器收到附带有 Connection: Keep-Alive 的请求时，它也会在响应头中添加一个同样的字段来使用 Keep-Alive 。这样一来，客户端和服务器之间的HTTP连接就会被保持，不会断开（超过 Keep-Alive 规定的时间，意外断电等情况除外），当客户端发送另外一个请求时，就使用这条已经建立的连接。 在 HTTP 1.1 版本中，默认情况下所有连接都被保持，如果加入 “Connection: close” 才关闭。目前大部分浏览器都使用 HTTP 1.1 协议，也就是说默认都会发起 Keep-Alive 的连接请求了，所以是否能完成一个完整的 Keep-Alive 连接就看服务器设置情况。 由于 HTTP 1.0 没有官方的 Keep-Alive 规范，并且也已经基本被淘汰，以下讨论均是针对 HTTP 1.1 标准中的 Keep-Alive 展开的。 注意：&gt; - HTTP Keep-Alive 简单说就是保持当前的TCP连接，避免了重新建立连接。&gt; - HTTP 长连接不可能一直保持，例如 Keep-Alive: timeout=5, max=100，表示这个TCP通道可以保持5秒，max=100，表示这个长连接最多接收100次请求就断开。&gt; - HTTP是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive没能改变这个结果。另外，Keep-Alive也不能保证客户端和服务器之间的连接一定是活跃的，在HTTP1.1版本中也如此。唯一能保证的就是当连接被关闭时你能得到一个通知，所以不应该让程序依赖于Keep-Alive的保持连接特性，否则会有意想不到的后果。&gt; - 使用长连接之后，客户端、服务端怎么知道本次传输结束呢？两部分：1. 判断传输数据是否达到了Content-Length 指示的大小；2. 动态生成的文件没有 Content-Length ，它是分块传输（chunked），这时候就要根据 chunked 编码来判断，chunked 编码的数据在最后有一个空 chunked 块，表明本次传输数据结束。 2. 请求报头 请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。 常用的请求报头 ==Accept== Accept 请求报头域用于指定客户端接受哪些类型的信息。eg：Accept：image/gif，表明客户端希望接受 GIF 图象格式的资源；Accept：text/html，表明客户端希望接受 html 文本。 ==Accept-Charset== Accept-Charset 请 求 报 头 域 用 于 指 定 客 户 端 接 受 的 字 符 集 。 eg ：Accept-Charset:iso-8859-1,gb2312.如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。 ==Accept-Encoding== Accept-Encoding 请求报头域类似于 Accept，但是它是用于指定可接受的内容编码。eg：Accept-Encoding:gzip.deflate.如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。 ==Accept-Language== Accept-Language 请 求 报 头 域 类 似 于 Accept ， 但 是 它 是 用 于 指 定 一 种 自 然 语 言 。 eg ：Accept-Language:zh-cn.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。 ==Authorization== Authorization 请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为 401（未授权），可以发送一个包含 Authorization 请求报头域的请求，要求服务器对其进行验证。 ==Host==（发送请求时，该报头域是必需的） Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。eg:我们在浏览器中输入： https://www.baidu.com/index.html浏览器发送的请求消息中，就会包含 Host 请求报头域，如下：Host：www.baidu.com此处使用缺省端口号 443，若指定了端口号，则变成：Host：www.baidu.com:指定端口号 ==user-Agent==User-Agent 请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。 3. 响应报头响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI 所标识的资源进行下一步访问的信息。 常用的响应报头： ==Location== Location响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用于更换域名的时候。 ==Server==Server响应报头域包含了服务器用来处理请求的软件信息。与user-Agent请求报头域是相对应的。eg:Server:nginx;使用的服务器为nginx4、实体报头请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息 常用的实体报头: ==Content-Encoding== Content-Encoding 实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得 Content-Type 报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding 这样用于记录文档的压缩方法，eg：Content-Encoding：gzip ==Content-Language== 描述了资源所用的自然语言。 ==Content-Length== Content-Length 实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。 ==Content-Type== Content-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。eg：Content-Type:text/html;charset=ISO-8859-1 ==Last-Modified== Last-Modified 实体报头域用于指示资源的最后修改日期和时间。 ==Expires== Expires 实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用 Expires 实体报头域指定页面过期的时间。eg：Expires：Thu，15 Sep 2006 16:23:12GMT","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://wkd709.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://wkd709.github.io/tags/HTTP/"}]}]}